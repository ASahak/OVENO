{"ast":null,"code":"import _Object$defineProperty from \"@babel/runtime-corejs2/core-js/object/define-property\";\nimport _Object$defineProperties from \"@babel/runtime-corejs2/core-js/object/define-properties\";\nimport _Object$getOwnPropertyDescriptors from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\";\nimport _Object$getOwnPropertyDescriptor from \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\";\nimport _Object$getOwnPropertySymbols from \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\";\nimport _Object$entries from \"@babel/runtime-corejs2/core-js/object/entries\";\nimport _defineProperty from \"@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _Object$values from \"@babel/runtime-corejs2/core-js/object/values\";\nimport _Promise from \"@babel/runtime-corejs2/core-js/promise\";\nimport _JSON$stringify from \"@babel/runtime-corejs2/core-js/json/stringify\";\nimport _Object$keys from \"@babel/runtime-corejs2/core-js/object/keys\";\nvar __jsx = React.createElement;\n\nfunction ownKeys(object, enumerableOnly) { var keys = _Object$keys(object); if (_Object$getOwnPropertySymbols) { var symbols = _Object$getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return _Object$getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (_Object$getOwnPropertyDescriptors) { _Object$defineProperties(target, _Object$getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { _Object$defineProperty(target, key, _Object$getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { Fragment, useState, useEffect, useCallback } from 'react';\nimport classes from './categories.scss';\nimport { Modal, ModalHeader, ModalBody, Tooltip } from 'reactstrap';\nimport Icon from 'components/Icons/icon';\nimport { ONLY_ENGLISH_LETTERS_WITH_DIGIT_PATTERN } from \"utils\";\nimport UI_ELEMENTS from \"components/shared/UI\";\nimport { useForm } from \"react-hook-form\";\nimport axios from \"lib/axiosEnv\";\nimport { toast } from \"react-toastify\";\nimport { __SET_CATEGORY_LIST } from 'store/actions';\nimport { connect } from \"react-redux\";\nimport Router from \"next/router\";\n\nconst {\n  getToken\n} = require('utils/auth');\n\nimport { Bus } from 'lib/EventEmitter';\n\nconst CRUDCategoryForm = props => {\n  const {\n    register,\n    handleSubmit,\n    errors,\n    reset,\n    setValue\n  } = useForm({\n    mode: 'onBlur'\n  });\n  const {\n    0: loadingCategory,\n    1: setLoadingCategory\n  } = useState(false);\n  const {\n    0: tooltipOpen,\n    1: setTooltipOpen\n  } = useState(false);\n  const {\n    0: typeCRUD,\n    1: setTypeCRUD\n  } = useState('');\n  const {\n    0: subCategoryContent,\n    1: setSubCategoryContent\n  } = useState([]);\n  const {\n    0: categoryContent,\n    1: setCategoryContent\n  } = useState('');\n  const {\n    0: deepCategoryContent,\n    1: setDeepCategoryContent\n  } = useState(null);\n  const toastOpt = {\n    position: \"top-right\",\n    autoClose: 3000,\n    pauseOnHover: false\n  };\n\n  const toggle = () => setTooltipOpen(!tooltipOpen); // Generate new ParamName\n\n\n  const generateName = (begin, state) => {\n    if (state.some(s => s.name === 'subCategory' + begin)) {\n      return generateName(begin + 1, state);\n    } else return 'subCategory' + begin;\n  };\n\n  const addSubCategoryField = () => {\n    setSubCategoryContent(prevState => [...prevState, {\n      value: '',\n      name: generateName(0, subCategoryContent)\n    }]);\n  };\n\n  const saveChanges = data => {\n    const fakeCategories = [...subCategoryContent];\n    const index = fakeCategories.findIndex(item => item.name === data.name);\n\n    if (index > -1) {\n      fakeCategories[index].value = data.value;\n    }\n  };\n\n  const removeCategory = useCallback((name, state) => {\n    if (name === 'name') {\n      setCategoryContent('removed');\n      setSubCategoryContent([]);\n      return;\n    }\n\n    const prevState = [...state];\n    const indexRem = prevState.findIndex(obj => obj.name === name);\n\n    if (indexRem > -1) {\n      prevState.splice(indexRem, 1);\n    }\n\n    setSubCategoryContent(prevState);\n  }, [categoryContent, subCategoryContent]);\n  useEffect(() => {\n    if (_Object$keys(props.editCategoryData).length) {\n      // Saving Cloned Data before editing\n      setDeepCategoryContent(JSON.parse(_JSON$stringify(props.editCategoryData)));\n      setValue('name', props.editCategoryData.text);\n      setCategoryContent(props.editCategoryData.text);\n      props.editCategoryData.dataSub.forEach(el => {\n        setSubCategoryContent(prevState => [...prevState, {\n          value: el.text,\n          name: el.id\n        }]);\n      });\n    }\n  }, [props.editCategoryData]);\n  useEffect(() => {\n    setTypeCRUD(props.crudType);\n  }, [props.crudType]);\n  useEffect(() => {\n    subCategoryContent.forEach(e => {\n      if (props.crudType === 'edit') {\n        setValue(e.name, e.value);\n      }\n    });\n  }, [subCategoryContent]);\n\n  const reflect = promise => {\n    return promise.then(function (v) {\n      return {\n        v: v,\n        status: \"fulfilled\"\n      };\n    }, function (e) {\n      return {\n        e: e,\n        status: \"rejected\"\n      };\n    });\n  };\n\n  const onSubmit = async dataCategory => {\n    try {\n      if (typeCRUD === 'edit') {\n        let editedObj = {};\n        let parentSlug = deepCategoryContent.link.pathname.split('/').pop();\n\n        const getSubCategories = _Object$keys(dataCategory).reduce((acc, sub) => {\n          if (sub !== 'name') {\n            if (!deepCategoryContent.dataSub.find(obj => obj.id === sub)) {\n              acc[sub] = dataCategory[sub];\n            } else {\n              acc[sub] = {\n                name: deepCategoryContent.dataSub.find(obj => obj.id === sub).text,\n                newName: dataCategory[sub],\n                category: deepCategoryContent.text\n              };\n            }\n          }\n\n          return acc;\n        }, {});\n\n        if (!dataCategory.hasOwnProperty('name')) {\n          const {\n            data\n          } = await axios.delete('/api/remove/category', {\n            headers: {\n              Authorization: getToken('token')\n            },\n            data: {\n              name: deepCategoryContent.text\n            }\n          });\n          if (data.error) throw Error(data.error);\n          toast.dark(data.message, toastOpt);\n          props.handlerForm(typeCRUD, {\n            name: deepCategoryContent.text,\n            removed: true\n          });\n          return;\n        }\n\n        const [added, removed, updated] = [[], [], []];\n\n        if (dataCategory.name && dataCategory.name !== deepCategoryContent.text) {\n          updated.push({\n            name: deepCategoryContent.text,\n            text: dataCategory.name\n          });\n        } // Added\n\n\n        _Object$keys(getSubCategories).forEach(obj => {\n          if (obj.indexOf('subCategory') > -1) {\n            added.push({\n              [obj]: getSubCategories[obj]\n            });\n          }\n        }); // Removed\n\n\n        deepCategoryContent.dataSub.forEach(rem => {\n          if (!getSubCategories.hasOwnProperty(rem.id)) {\n            removed.push({\n              name: rem.text,\n              category: deepCategoryContent.text\n            });\n          }\n        }); // Updated\n\n        deepCategoryContent.dataSub.forEach(rem => {\n          if (getSubCategories.hasOwnProperty(rem.id) && getSubCategories[rem.id].newName !== rem.text) {\n            const obj = getSubCategories[rem.id];\n            updated.push({\n              subName: obj.name,\n              text: obj.newName,\n              category: obj.category\n            });\n          }\n        });\n        const [addPromise, updatePromise, removePromise] = [[], [], []];\n\n        for (const add of added) {\n          addPromise.push(new _Promise((resolve, reject) => {\n            axios.post('/api/add/subCategory', {\n              name: _Object$values(add)[0],\n              category: dataCategory.name\n            }, {\n              headers: {\n                Authorization: getToken('token')\n              }\n            }).then(res => resolve(res)).catch(err => reject(err));\n          }));\n        }\n\n        for (const rem of removed) {\n          removePromise.push(new _Promise((resolve, reject) => {\n            axios.delete('/api/delete/subCategory', {\n              headers: {\n                Authorization: getToken('token')\n              },\n              data: {\n                name: rem.name,\n                category: rem.category\n              }\n            }).then(res => resolve(res)).catch(err => reject(err));\n          }));\n        }\n\n        for (const up of updated) {\n          if (up.subName) {\n            // For sub Categories\n            updatePromise.push(new _Promise((resolve, reject) => {\n              axios.put('/api/update/subCategory', {\n                name: up.subName,\n                newName: up.text,\n                category: up.category\n              }, {\n                headers: {\n                  Authorization: getToken('token')\n                }\n              }).then(res => resolve(res)).catch(err => reject(err));\n            }));\n          } else {\n            // For Categories\n            updatePromise.push(new _Promise((resolve, reject) => {\n              axios.put('/api/update/category', {\n                name: up.name,\n                text: up.text\n              }, {\n                headers: {\n                  Authorization: getToken('token')\n                }\n              }).then(res => resolve(res)).catch(err => reject(err));\n            }));\n          }\n        }\n\n        const promiseAllArr = [...updatePromise, ...addPromise, ...removePromise];\n        const results = await _Promise.all(promiseAllArr.map(reflect));\n        const success = results.filter(x => x.status === \"fulfilled\");\n\n        if (success.length !== promiseAllArr.length) {\n          toast.error('Some request went wrong!', toastOpt);\n        } else {\n          toast.dark('Requests was gone successfully!', toastOpt);\n          const updatedCategory = success.filter(x => x.v.data.updatedCategory);\n          const updatedSubCategory = success.filter(x => x.v.data.updatedSubCategory);\n          const addedSubCategory = success.filter(x => x.v.data.subCategory);\n          const removedSubCategory = success.filter(x => x.v.data.removedSubCategory);\n          editedObj.dataSub = deepCategoryContent.dataSub;\n          editedObj.data = {\n            name: deepCategoryContent.text,\n            edited: true\n          };\n\n          if (updatedCategory.length) {\n            editedObj.data.newName = updatedCategory[0].v.data.updatedCategory.name;\n            parentSlug = editedObj.data.newSlug = updatedCategory[0].v.data.updatedCategory.slug;\n            editedObj.dataSub.forEach(el => {\n              const linkSub = el.link.pathname.split('/').pop();\n              el.link.pathname = '/shop/' + parentSlug + '/' + linkSub;\n            });\n          }\n\n          if (updatedSubCategory.length) {\n            updatedSubCategory.forEach(el => {\n              const findOldSub = editedObj.dataSub.findIndex(i => i.text === el.v.data.updatedSubCategory.oldName);\n\n              if (findOldSub > -1) {\n                editedObj.dataSub[findOldSub].text = el.v.data.updatedSubCategory.name;\n                editedObj.dataSub[findOldSub].link.pathname = '/shop/' + parentSlug + '/' + el.v.data.updatedSubCategory.slug;\n              }\n            });\n          }\n\n          if (removedSubCategory.length) {\n            removedSubCategory.forEach(el => {\n              const findRemSub = editedObj.dataSub.findIndex(i => i.text === el.v.data.removedSubCategory.name);\n\n              if (findRemSub > -1) {\n                editedObj.dataSub.splice(findRemSub, 1);\n              }\n            });\n          }\n\n          if (addedSubCategory.length) {\n            addedSubCategory.forEach(el => {\n              const added = el.v.data.subCategory;\n\n              if (added) {\n                editedObj.dataSub.push({\n                  id: added._id,\n                  text: added.name,\n                  link: {\n                    pathname: '/shop/' + parentSlug + '/' + added.slug\n                  }\n                });\n              }\n            });\n          }\n\n          props.handlerForm(typeCRUD, editedObj.data, editedObj.dataSub);\n        }\n      } else {\n        const getSubCategories = _Object$keys(dataCategory).reduce((acc, sub) => {\n          if (sub !== 'name') acc[sub] = dataCategory[sub];\n          return acc;\n        }, {}); // Remove all Sub category fields before creating\n\n\n        if (_Object$keys(getSubCategories).length) {\n          _Object$keys(getSubCategories).forEach(remSub => delete dataCategory[remSub]);\n        }\n\n        const {\n          data\n        } = await axios.post('/api/add/category', dataCategory, {\n          headers: {\n            Authorization: getToken('token')\n          }\n        });\n\n        if (data.error) {\n          throw Error(data.error.message || data.error);\n        } // If there are SubCategories\n\n\n        const promisesSub = [];\n        const subData = [];\n        let subCategoriesFail = false;\n        await (() => {\n          if (_Object$keys(getSubCategories).length) {\n            for (let i = 0, p = _Promise.resolve(); i < _Object$keys(getSubCategories).length; i++) {\n              p = p.then(_ => new _Promise(async resolve => {\n                const dataSub = await axios.post('/api/add/subCategory', {\n                  name: getSubCategories[_Object$keys(getSubCategories)[i]],\n                  category: data.category.name\n                }, {\n                  headers: {\n                    Authorization: getToken('token')\n                  }\n                });\n                if (dataSub.data.error) subCategoriesFail = true;else {\n                  subData.push(dataSub.data.subCategory);\n                }\n                resolve();\n              }));\n              promisesSub.push(p);\n            }\n          }\n\n          return _Promise.all(promisesSub);\n        })();\n\n        if (subCategoriesFail) {\n          throw Error('Something went wrong with Sub Categories!');\n        } else {\n          toast.dark(data.message, toastOpt);\n          props.handlerForm(typeCRUD, data, subData);\n        }\n      }\n    } catch (err) {\n      toast.error(err.response ? err.response.data : err.message, toastOpt);\n    } finally {\n      props.closeModal();\n      reset();\n    }\n  };\n\n  return __jsx(React.Fragment, null, __jsx(\"form\", {\n    id: \"category-form\",\n    onSubmit: handleSubmit(onSubmit)\n  }, categoryContent !== 'removed' ? __jsx(\"div\", {\n    className: classes['parentUI-input']\n  }, __jsx(UI_ELEMENTS.Input, {\n    type: \"text\",\n    name: \"name\",\n    refBind: categoryContent ? React.createRef() : register(ONLY_ENGLISH_LETTERS_WITH_DIGIT_PATTERN),\n    errors: errors.name && errors.name.message,\n    fullWidth: true,\n    placeholder: \"Name\",\n    size: \"sm\"\n  }), __jsx(\"span\", {\n    className: classes['remove-icon'],\n    onClick: () => removeCategory('name', categoryContent)\n  }, __jsx(Icon, {\n    name: \"close\"\n  }))) : '', subCategoryContent.length ? __jsx(\"div\", {\n    className: classes.subCategoryContent\n  }, \" \", subCategoryContent.map((_, index) => __jsx(\"div\", {\n    key: _.category + _.name,\n    className: classes['parentUI-input']\n  }, __jsx(UI_ELEMENTS.Input, {\n    type: \"text\",\n    events: ['change'],\n    onChange: e => saveChanges({\n      value: e.target.value,\n      name: _.name\n    }),\n    name: _.name,\n    refBind: register(ONLY_ENGLISH_LETTERS_WITH_DIGIT_PATTERN),\n    errors: errors[_.name] && errors[_.name].message,\n    fullWidth: true,\n    placeholder: \"Sub category name\",\n    size: \"sm\"\n  }), __jsx(\"span\", {\n    className: classes['remove-icon'],\n    onClick: () => removeCategory(_.name, subCategoryContent)\n  }, __jsx(Icon, {\n    name: \"close\"\n  }))))) : '', __jsx(\"div\", {\n    className: classes.addCategory\n  }, __jsx(UI_ELEMENTS.Button, {\n    icon: loadingCategory ? {\n      dir: 'right',\n      element: 'loading'\n    } : {},\n    type: \"submit\",\n    text: \"Save\",\n    width: 100,\n    margin: ['0px', '0', '0', 'auto'],\n    attr: [{\n      id: 'saveBtn'\n    }],\n    size: \"sm\"\n  }), categoryContent !== 'removed' ? __jsx(\"a\", {\n    id: \"add-category-sub\",\n    onClick: addSubCategoryField\n  }, \"+\") : ''), __jsx(Tooltip, {\n    placement: \"right\",\n    isOpen: tooltipOpen,\n    target: \"add-category-sub\",\n    toggle: toggle\n  }, \"Add Sub Category\")));\n};\n\nconst Li = function (props) {\n  const {\n    data,\n    parent\n  } = props;\n  let {\n    0: open,\n    1: setOpen\n  } = useState(false);\n  let {\n    0: height,\n    1: setHeight\n  } = useState(0);\n\n  const openSubMenu = (evt, index) => {\n    setHeight(height = 0);\n    evt.stopPropagation();\n    evt.preventDefault();\n    setOpen(open = parent.current.children[index] && parent.current.children[index].classList.contains('openItemDropdown'));\n    parent.current.children[index].classList[!open ? 'add' : 'remove']('openItemDropdown');\n    !open ? parent.current.children[index].querySelectorAll('.' + classes[\"submenu_dropdown\"] + ' > li').forEach(_ => setHeight(height += _.getBoundingClientRect().height)) : setHeight(height = 0);\n    parent.current.children[index].querySelector('.' + classes[\"submenu_dropdown\"]).style.maxHeight = height + 'px';\n  };\n\n  const goToShop = path => {\n    _Object$keys(Router.query).forEach(qu => {\n      // Remove unnecessary query params\n      if (qu !== 'name' && qu !== 'category' && qu !== 'subCategory' && qu !== 'page' && qu !== 'maxPrice' && qu !== 'minPrice') delete Router.query[qu];\n    });\n\n    const query = _objectSpread({}, Router.query);\n\n    if (path.hasOwnProperty('querySubCategory')) {\n      query.category = path.queryCategory;\n      query.subCategory = path.querySubCategory;\n    } else if (path.hasOwnProperty('queryCategory')) {\n      query.category = path.queryCategory;\n      delete query.subCategory;\n    }\n\n    query.page = 1;\n    Router.push({\n      pathname: '/shop',\n      query: _objectSpread({}, query)\n    }).then(() => Bus.dispatch('filterByCategory'));\n  };\n\n  const openModal = (el, index) => {\n    setHeight(0);\n    setOpen(true);\n    parent.current.children[index].classList.remove('openItemDropdown');\n\n    if (!open && parent.current.children[index].querySelector('.' + classes[\"submenu_dropdown\"])) {\n      parent.current.children[index].querySelector('.' + classes[\"submenu_dropdown\"]).style.maxHeight = '0px';\n    }\n\n    props.openPropModal(el);\n  };\n\n  if (data instanceof Object) {\n    const _li = _Object$keys(data).map((_el, index) => {\n      const display = data[_el].link.pathname ? __jsx(\"a\", {\n        onClick: () => goToShop(data[_el])\n      }, data[_el].text, \" \", data[_el].hasOwnProperty('dataSub') && _Object$keys(data[_el].dataSub).length > 0 ? __jsx(\"span\", {\n        className: classes[\"dropdown_arrow\"],\n        onClick: e => openSubMenu(e, index)\n      }) : '') : __jsx(\"span\", null, data[_el].text);\n      let subMenu;\n\n      if (data[_el].hasOwnProperty('dataSub') && _Object$keys(data[_el].dataSub).length > 0) {\n        subMenu = __jsx(Li, {\n          data: data[_el].dataSub,\n          isAdmin: props.isAdmin\n        });\n      }\n\n      return __jsx(\"li\", {\n        key: index,\n        className: props.isAdmin ? 'admin-icon-relative' : ''\n      }, display, props.isAdmin && __jsx(\"span\", {\n        className: \"admin-icon\",\n        onClick: () => openModal(data[_el], index)\n      }, __jsx(Icon, {\n        name: \"pencil\"\n      })), subMenu ? __jsx(\"ul\", {\n        className: classes[\"submenu_dropdown\"]\n      }, subMenu) : '');\n    });\n\n    return __jsx(Fragment, null, _li);\n  }\n};\n\nclass Categories extends React.Component {\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"componentDidMount\", async () => {\n      try {\n        const {\n          data\n        } = await axios.get('/api/get/categories');\n        if (data.error) throw Error(data.error);\n        this.setState({\n          categoryList: (() => {\n            const list = {};\n\n            for (let i = 0; i < data.category.length; i++) {\n              list[data.category[i].name] = {\n                text: data.category[i].name,\n                queryCategory: data.category[i].slug,\n                link: {\n                  pathname: '/shop?category=' + data.category[i].slug + this.routerQueries(['category'])\n                },\n                dataSub: data.subCategory.reduce((acc, sub) => {\n                  if (sub.category === data.category[i].name) {\n                    acc.push({\n                      queryCategory: data.category[i].slug,\n                      querySubCategory: sub.slug,\n                      text: sub.name,\n                      id: sub._id,\n                      link: {\n                        pathname: '/shop?category=' + data.category[i].slug + '&subCategory=' + sub.slug + this.routerQueries(['category', 'subCategory'])\n                      }\n                    });\n                  }\n\n                  return acc;\n                }, [])\n              };\n            }\n\n            return list;\n          })()\n        }, () => {\n          this.props.__SET_CATEGORY_LIST(this.state.categoryList);\n        });\n      } catch (err) {\n        toast.error(err.response ? err.response.data : err.message, {\n          position: \"top-right\",\n          autoClose: 3000,\n          pauseOnHover: false\n        });\n      }\n    });\n\n    this.state = {\n      modal: false,\n      crudType: '',\n      categoryList: {},\n      editCategoryData: {}\n    };\n    this.openModal = this.openModal.bind(this);\n    this.routerQueries = this.routerQueries.bind(this);\n    this.handlerChangesCRUD = this.handlerChangesCRUD.bind(this);\n    this.categoryRef = React.createRef();\n  }\n\n  routerQueries(besides) {\n    let queries = '';\n\n    _Object$keys(Router.query).forEach(query => {\n      if (besides.indexOf(query) === -1) {\n        queries += '&' + query + '=' + Router.query[query];\n      }\n    });\n\n    return queries;\n  }\n\n  openModal(type = 'add', dataEdit = {}) {\n    this.setState({\n      editCategoryData: dataEdit,\n      crudType: typeof type === 'string' ? type : '',\n      modal: !this.state.modal\n    });\n  }\n\n  handlerChangesCRUD(type, data, subData = []) {\n    if (type === 'edit' && data.edited) {\n      const nameCategory = data.newName || data.name;\n      let prevStateCategory = this.state.categoryList;\n\n      if (data.newName) {\n        const nameCategorySlug = (() => {\n          const arr = prevStateCategory[data.name].link.pathname.split('/');\n          arr.pop();\n          arr.push(data.newSlug);\n          return arr.join('/');\n        })();\n\n        prevStateCategory[data.newName] = prevStateCategory[data.name];\n        delete prevStateCategory[data.name];\n        prevStateCategory[data.newName].text = nameCategory;\n        prevStateCategory[data.newName].link.pathname = nameCategorySlug;\n      }\n\n      const updatedCategoryList = JSON.parse(_JSON$stringify(prevStateCategory[nameCategory]));\n      updatedCategoryList.dataSub = subData;\n      prevStateCategory[nameCategory] = updatedCategoryList;\n      const orderedPrevStateCategory = {};\n\n      _Object$keys(prevStateCategory).sort().forEach(function (key) {\n        orderedPrevStateCategory[key] = prevStateCategory[key];\n      });\n\n      this.setState({\n        categoryList: _objectSpread({}, orderedPrevStateCategory)\n      });\n    } else if (type === 'edit' && data.removed) {\n      Object.filter = (obj, predicate) => Object.fromEntries(_Object$entries(obj).filter(predicate));\n\n      const removedCategory = Object.filter(this.state.categoryList, ([name, list]) => list.text !== data.name);\n      this.setState({\n        categoryList: removedCategory\n      });\n    } else {\n      this.setState(prevState => ({\n        categoryList: _objectSpread({}, prevState.categoryList, {\n          [data.category.name]: {\n            text: data.category.name,\n            link: {\n              pathname: '/shop/' + data.category.slug\n            },\n            dataSub: subData.map(sub => {\n              return {\n                id: sub._id,\n                text: sub.name,\n                link: {\n                  pathname: '/shop/' + data.category.slug + '/' + sub.slug\n                }\n              };\n            })\n          }\n        })\n      }));\n    }\n  }\n\n  isAdmin() {\n    return this.props.isAdmin && this.props.isAdmin.roleType === 'admin';\n  }\n\n  render() {\n    return __jsx(\"div\", {\n      className: classes[\"categories-container\"]\n    }, __jsx(Modal, {\n      isOpen: this.state.modal,\n      toggle: this.openModal\n    }, __jsx(ModalHeader, {\n      toggle: this.openModal\n    }, \"Add Category\"), __jsx(ModalBody, null, __jsx(CRUDCategoryForm, {\n      closeModal: this.openModal,\n      handlerForm: this.handlerChangesCRUD,\n      crudType: this.state.crudType,\n      editCategoryData: this.state.editCategoryData\n    }))), __jsx(\"div\", {\n      className: `${classes[\"categories-container-header\"]} ${this.isAdmin() ? 'admin-icon-relative' : ''}`\n    }, __jsx(\"h4\", null, \"Categories\"), this.isAdmin() && __jsx(\"span\", {\n      className: \"admin-icon\",\n      onClick: () => this.openModal('add')\n    }, __jsx(Icon, {\n      name: \"plus\"\n    }))), __jsx(\"div\", {\n      className: classes[\"categories-container-body\"]\n    }, __jsx(\"ul\", {\n      type: \"none\",\n      ref: this.categoryRef\n    }, __jsx(Li, {\n      data: this.state.categoryList,\n      parent: this.categoryRef,\n      isAdmin: this.isAdmin(),\n      openPropModal: data => this.openModal('edit', data)\n    }))));\n  }\n\n}\n\nconst mapStateToProps = state => ({\n  isAdmin: state.auth.user\n});\n\nconst mapDispatchToProps = {\n  __SET_CATEGORY_LIST\n};\nexport default connect(mapStateToProps, mapDispatchToProps)(Categories);","map":null,"metadata":{},"sourceType":"module"}